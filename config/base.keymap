#include <behaviors.dtsi>
#include <behaviors/num_word.dtsi> // Requires auto-layer module.
#include <dt-bindings/zmk/keys.h>
#ifdef CONFIG_WIRELESS
  #include <dt-bindings/zmk/bt.h>
  #include <dt-bindings/zmk/outputs.h>
  #define _BT_SEL_KEYS_LEFT_                                                        \
      &bt BT_SEL 0 &bt BT_SEL 1 &bt BT_SEL 2 &bt BT_SEL 3 &bt BT_CLR
  #define _BT_SEL_KEYS_RIGHT_                                                       \
      &bt BT_CLR &bt BT_SEL 3 &bt BT_SEL 2 &bt BT_SEL 1 &bt BT_SEL 0
#else
  #define _BT_SEL_KEYS_LEFT_  XXX  XXX  XXX  XXX  XXX
  #define _BT_SEL_KEYS_RIGHT_ XXX  XXX  XXX  XXX  XXX
#endif

#include "zmk-helpers/helper.h"
#include "zmk-helpers/unicode-chars/german.dtsi"

#define WIN_BASE 0
#define MAC_BASE 1
#define WIN_NAV 2
#define MAC_NAV 3
#define WIN_NUM 4
#define MAC_NUM 5
#define SYS 6

#define XXX &none
#define ___ &trans

/* Global defaults */

#define QUICK_TAP_MS 175

&sk {
  release-after-ms = <900>;
  quick-release;
};

&sl { // Allow sticky mods to chord across sticky layers.
  ignore-modifiers;
};

&lt {
  flavor = "balanced";
  tapping-term-ms = <200>;
  quick-tap-ms = <QUICK_TAP_MS>;
};

/* Homerow mods */

#define KEYS_L LT0 LT1 LT2 LT3 LT4 LM0 LM1 LM2 LM3 LM4 LB0 LB1 LB2 LB3 LB4
#define KEYS_R RT0 RT1 RT2 RT3 RT4 RM0 RM1 RM2 RM3 RM4 RB0 RB1 RB2 RB3 RB4
#define THUMBS LH2 LH1 LH0 RH0 RH1 RH2

#define MAKE_HRM(NAME, HOLD, TAP, TRIGGER_POS)                                 \
  ZMK_HOLD_TAP(NAME, bindings = <HOLD>, <TAP>; flavor = "balanced";            \
               tapping-term-ms = <280>; quick-tap-ms = <QUICK_TAP_MS>;         \
               require-prior-idle-ms = <150>; hold-trigger-on-release;         \
               hold-trigger-key-positions = <TRIGGER_POS>;)

MAKE_HRM(hml, &kp, &kp, KEYS_R THUMBS) // Left-hand HRMs.
MAKE_HRM(hmr, &kp, &kp, KEYS_L THUMBS) // Right-hand HRMs.

/* Combos, leader key sequences, mouse emulation */

#include "combos.dtsi" // Must be sourced after HRM-combo hack.
#include "leader.dtsi"

/* Nav cluster */

// Trigger tap-action on all interrupts.
#define MT_CORE                                                                \
  flavor = "tap-preferred";                                                    \
  tapping-term-ms = <220>;                                                     \
  quick-tap-ms = <220>;                                                        \
  hold-trigger-key-positions = <0>;

&mt { MT_CORE };

ZMK_HOLD_TAP(mt_home, bindings = <&masked_home>, <&kp>; MT_CORE)
ZMK_HOLD_TAP(mt_end, bindings = <&masked_end>, <&kp>; MT_CORE)

#define NAV_LEFT    &mt_home 0    LEFT  // Tap: left  | Long-tap: start of line.
#define NAV_RIGHT   &mt_end 0     RIGHT // Tap: right | Long-tap: end   of line.
#define NAV_UP      &mt PG_UP     UP    // Tap: up    | Long-tap: half-page up.
#define NAV_DOWN    &mt PG_DN     DOWN  // Tap: down  | Long-tap: half-page down.

#define BSPC_MORPH  &mt LC(BSPC)  BSPC  // tap: bspc  | long-tap: delete word backward
#define WIN_DEL_MORPH   &mt LC(DEL)   DEL   // tap: del   | long-tap: delete word forward
#define MAC_DEL_MORPH   &mt LA(DEL)   DEL   // tap: del   | long-tap: delete word forward

#define DOT_MORPH   &mt_dot 0     DOT       // tap: . | long-tap: dot space sticky shift

// Mask CTRL on left/right hold to avoid accidental jumps to start/end of doc.
#define MASK_MODS(NAME, MODS, BINDING)                                         \
  ZMK_MOD_MORPH(NAME, bindings = <BINDING>, <BINDING>; mods = <MODS>;)

MASK_MODS(masked_home, (MOD_LCTL), &kp HOME)
MASK_MODS(masked_end,  (MOD_LCTL), &kp END)

/* Custom behaviors */

// Define mod-morph with a *single* mod trigger for less repetition.
#define SIMPLE_MORPH(NAME, MOD, BINDING1, BINDING2)                            \
  ZMK_MOD_MORPH(NAME, mods = <(MOD_L##MOD | MOD_R##MOD)>;                      \
                bindings = <BINDING1>, <BINDING2>;)

// Try reversing the order - check for Ctrl+Shift first
ZMK_MOD_MORPH(qmark_morph,
    bindings = <&qmark_no_ctrl>, <&qmark_with_ctrl>;
    mods = <(MOD_LCTL | MOD_RCTL)>;
)

ZMK_MOD_MORPH(qmark_no_ctrl,
    bindings = <&kp QMARK>, <&kp FSLH>;
    mods = <(MOD_LSFT | MOD_RSFT)>;
)

ZMK_MOD_MORPH(qmark_with_ctrl,
    bindings = <&kp QMARK>, <&kp BSLH>;
    mods = <(MOD_LSFT | MOD_RSFT)>;
)

// tap: " | shift + tap: ' | ctrl + shift + tap: `
SIMPLE_MORPH(quote_morph, SFT, &kp DQT, &quote_inner_morph)
SIMPLE_MORPH(quote_inner_morph, CTL, &kp SQT, &kp GRAVE)

SIMPLE_MORPH(equal_morph, SFT, &kp EQUAL, &kp PLUS)         // tap: = | shift + tap: +
SIMPLE_MORPH(minus_morph, SFT, &kp MINUS, &kp UNDER)        // tap: - | shift + tap: _
SIMPLE_MORPH(lbkt_morph, SFT, &kp LBKT, &kp LBRC)           // tap: [ | shift + tap: {
SIMPLE_MORPH(rbkt_morph, SFT, &kp RBKT, &kp RBRC)           // tap: ] | shift + tap: }
SIMPLE_MORPH(pipe_morph, SFT, &kp PIPE, &kp TILDE)          // tap: | | shift + tap: ~
SIMPLE_MORPH(comma_morph, SFT, &kp COMMA, &kp LESS_THAN)    // tap: , | shift + tap: <
//SIMPLE_MORPH(dot_morph, SFT, &kp DOT, &kp GREATER_THAN)     // tap: . | shift + tap: >

// Tap: space | Shift + tap: dot -> space -> sticky shift | Hold: nav layer.
ZMK_HOLD_TAP(lt_spc, bindings = <&mo>, <&spc_morph>; flavor = "balanced";
             tapping-term-ms = <200>; quick-tap-ms = <QUICK_TAP_MS>;)
SIMPLE_MORPH(spc_morph, SFT, &kp SPACE, &dot_spc)
// Press dot, space and sticky shift at the same time with one keypress
ZMK_MACRO(dot_spc,
    wait-ms = <0>;
    tap-ms = <5>;
    bindings = <&kp DOT &kp SPACE &sk LSHFT>;
)

ZMK_HOLD_TAP(mt_dot, bindings = <&dot_spc>, <&kp>; MT_CORE)

// Base (WIN) layer
#define WIN_BASE_LT  &kp Q            &kp W           &kp E           &kp R           &kp T
#define WIN_BASE_RT  &kp Y            &kp U           &kp I           &kp O           &kp P
#define WIN_BASE_LM  &hml LGUI A      &hml LALT S     &hml LCTRL D    &hml LSHFT F    &kp G
#define WIN_BASE_RM  &kp H            &hmr RSHFT J    &hmr RCTRL K    &hmr RALT L     &hmr RGUI SEMI
#define WIN_BASE_LB  &kp Z            &kp X           &kp C           &kp V           &kp B
#define WIN_BASE_RB  &kp N            &kp M           &comma_morph    DOT_MORPH       &qmark_morph
#define WIN_BASE_LH  &lt WIN_NAV ESC  BSPC_MORPH      WIN_DEL_MORPH
#define WIN_BASE_RH  &kp ENTER        &kp SPACE       &lt WIN_NUM TAB

// Base (MAC) layer
#define MAC_BASE_LT  &kp Q            &kp W           &kp E           &kp R           &kp T
#define MAC_BASE_RT  &kp Y            &kp U           &kp I           &kp O           &kp P
#define MAC_BASE_LM  &hml LCTRL A     &hml LALT S     &hml LGUI D     &hml LSHFT F    &kp G
#define MAC_BASE_RM  &kp H            &hmr RSHFT J    &hmr RCTRL K    &hmr RALT L     &hmr RGUI SEMI
#define MAC_BASE_LB  &kp Z            &kp X           &kp C           &kp V           &kp B
#define MAC_BASE_RB  &kp N            &kp M           &comma_morph    DOT_MORPH       &qmark_morph
#define MAC_BASE_LH  &lt MAC_NAV ESC  BSPC_MORPH      MAC_DEL_MORPH
#define MAC_BASE_RH  &kp ENTER        &kp SPACE       &lt MAC_NUM TAB

// Navigation (WIN) layer
#define WIN_NAV_LT  XXX             XXX             XXX             XXX             &kp C_VOL_UP
#define WIN_NAV_RT  &kp PG_UP       XXX             NAV_UP          XXX             &kp PSCRN
#define WIN_NAV_LM  &kp LGUI        &kp LALT        &kp LCTRL       &kp LSHFT       &kp C_MUTE
#define WIN_NAV_RM  &kp PG_DN       NAV_LEFT        NAV_DOWN        NAV_RIGHT       &kp INS
#define WIN_NAV_LB  XXX             XXX             XXX             XXX             &kp C_VOL_DN
#define WIN_NAV_RB  XXX             XXX             XXX             XXX             XXX
#define WIN_NAV_LH  ___             ___             ___
#define WIN_NAV_RH  ___             ___             ___

// Navigation (MAC) layer
#define MAC_NAV_LT  XXX             XXX             XXX             XXX             &kp C_VOL_UP
#define MAC_NAV_RT  &kp PG_UP       XXX             NAV_UP          XXX             &kp PSCRN
#define MAC_NAV_LM  &kp LCTRL       &kp LALT        &kp LGUI        &kp LSHFT       &kp C_MUTE
#define MAC_NAV_RM  &kp PG_DN       NAV_LEFT        NAV_DOWN        NAV_RIGHT       &kp INS
#define MAC_NAV_LB  XXX             XXX             XXX             XXX             &kp C_VOL_DN
#define MAC_NAV_RB  XXX             XXX             XXX             XXX             XXX
#define MAC_NAV_LH  ___             ___             ___
#define MAC_NAV_RH  ___             ___             ___

// Numeric (WIN) layer
#define WIN_NUM_LT  &kp EXCL        &kp AT          &kp HASH        &kp DLLR        &kp PRCNT
#define WIN_NUM_RT  &kp CARET       &kp AMPS        &kp STAR        &kp LPAR        &kp RPAR
#define WIN_NUM_LM  &hml LGUI N1    &hml LALT N2    &hml LCTRL N3   &hml LSHFT N4   &kp N5
#define WIN_NUM_RM  &kp N6          &hmr RSHFT N7   &hmr RCTRL N8   &hmr RALT N9    &hmr RGUI N0
#define WIN_NUM_LB  &kp F2          &kp F3          &kp F4          &kp F5          &kp F6
#define WIN_NUM_RB  &kp F7          &kp F8          &kp F9          &kp F10         &kp F11
#define WIN_NUM_LH  ___             ___             ___
#define WIN_NUM_RH  ___             ___             ___

// Numeric (MAC) layer
#define MAC_NUM_LT  &kp EXCL        &kp AT          &kp HASH        &kp DLLR        &kp PRCNT
#define MAC_NUM_RT  &kp CARET       &kp AMPS        &kp STAR        &kp LPAR        &kp RPAR
#define MAC_NUM_LM  &hml LCTRL N1   &hml LALT N2    &hml LGUI N3    &hml LSHFT N4   &kp N5
#define MAC_NUM_RM  &kp N6          &hmr RSHFT N7   &hmr RGUI N8    &hmr RALT N9    &hmr RCTRL N0
#define MAC_NUM_LB  &kp F2          &kp F3          &kp F4          &kp F5          &kp F6
#define MAC_NUM_RB  &kp F7          &kp F8          &kp F9          &kp F10         &kp F11
#define MAC_NUM_LH  ___             ___             ___
#define MAC_NUM_RH  ___             ___             ___

// System (SYS) layer
#define SYS_LT  &bootloader     &studio_unlock  XXX             XXX             XXX
#define SYS_RT  XXX             XXX             XXX             &studio_unlock  &bootloader
#define SYS_LM   _BT_SEL_KEYS_LEFT_
#define SYS_RM   _BT_SEL_KEYS_RIGHT_
#define SYS_LB  &sys_reset      XXX             XXX             XXX             &tog MAC_BASE
#define SYS_RB  &tog MAC_BASE   XXX             XXX             XXX             &sys_reset
#define SYS_LH  ___             XXX             XXX
#define SYS_RH  XXX             XXX             ___

// The tri-layer condition definition remains here (layer instantiation moved to hardware file).
ZMK_CONDITIONAL_LAYER(sys_win, WIN_NAV WIN_NUM, SYS)
ZMK_CONDITIONAL_LAYER(sys_mac, MAC_NAV MAC_NUM, SYS)